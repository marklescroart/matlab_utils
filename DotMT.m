function DotMT()%function mt(whichScreen,nRepeat)%%An MT localizer of moving dots, with the same parameters as Xiangrui's MT localizer (mt.m). %Based on DotDemo.m of Psychophisics toolbox and Xiangrui's code. %suggested by ml and written by oaAssertOpenGL;%(whichScreen,nRepeat)%if nargin<2; nRepeat=8; end%if nargin<1; whichScreen=max(Screen('Screens')); end%------------------%Timing parameters:%------------------nRepeat=8;% the number of blocksblockSecs = 24;%The length of each block (consists of moving+still presentations)stimSecs= blockSecs/2;lagg=8; % secs before start of experimenttotalSecs=lagg+blockSecs*nRepeat;    % ------------------------    % set dot field parameters    % ------------------------    nframes     = 1000; % number of animation frames in loop    mon_width   = 39;   % horizontal dimension of viewable screen (cm)    v_dist      = 60;   % viewing distance (cm)    dot_speed   = 7;    % dot speed (deg/sec)    ndots       = 2000; % number of dots    max_d       = 15;   % maximum radius of  annulus (degrees)    min_d       = 1;    % minumum    dot_w       = 0.1;  % width of dot (deg)    fix_r       = 0.15; % radius of fixation point (deg)    f_kill      = 0.05; % fraction of dots to kill each frame (limited lifetime)        differentcolors =0; % Use a different color for each point if == 1. Use common color white if == 0.    differentsizes = 2; % Use different sizes for each point if >= 1. Use one common size if == 0.    waitframes = 1;     % Show new dot-images at each waitframes'th monitor refresh.        if differentsizes>0  % drawing large dots is a bit slower        ndots=round(ndots/5);    end        % ---------------    % open the screen    % ---------------    doublebuffer=1;    screens=Screen('Screens');	screenNumber=max(screens);    % [w, rect] = Screen('OpenWindow', screenNumber, 0,[1,1,801,601],[], doublebuffer+1);    [w, rect] = Screen('OpenWindow', screenNumber, 0,[], 32, doublebuffer+1);            % Enable alpha blending with proper blend-function. We need it    % for drawing of smoothed points:    Screen('BlendFunction', w, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);    [center(1), center(2)] = RectCenter(rect);	 fps=Screen('FrameRate',w);      % frames per second    ifi=Screen('GetFlipInterval', w);    if fps==0       fps=1/ifi;    end;        black = BlackIndex(w);    white = WhiteIndex(w);    HideCursor;	% Hide the mouse cursor    Priority(MaxPriority(w));                %display instructions:    dispStr='Please fix at the center during scan';    centerFixation(w,dispStr, 40, 255);    Screen('Flip',w);    %audioFeedback(1);    ck.motionStart=zeros(1,nRepeat);    ck.motionEnd=zeros(1,nRepeat);        startSecs=WaitTrigger;    ck.expStart=getsecs-startSecs;                            breakSecs=((0:nRepeat-1))*blockSecs+stimSecs+lagg+startSecs;         %matching time variables to flip interval    breakSecs=round(breakSecs/ifi)*ifi;    lagg=round(lagg/ifi)*ifi;    stimSecs=round(stimSecs/ifi)*ifi;        %WaitTill(startSecs+lagg-0.01);    i=1; m=1; ss=zeros(0,3);    [key, secs]=readKey('1');                % Do initial flip...    vbl=Screen('Flip', w);        % ---------------------------------------    % initialize dot positions and velocities    % ---------------------------------------    ppd = pi * (rect(3)-rect(1)) / atan(mon_width/v_dist/2) / 360;    % pixels per degree    pfs = dot_speed * ppd / fps;                            % dot speed (pixels/frame)    s = dot_w * ppd;                                        % dot size (pixels)    fix_cord = [center-fix_r*ppd center+fix_r*ppd];    rmax = max_d * ppd;	% maximum radius of annulus (pixels from center)    rmin = min_d * ppd; % minimum    r = rmax * sqrt(rand(ndots,1));	% r    r(r<rmin) = rmin;    t = 2*pi*rand(ndots,1);                     % theta polar coordinate    cs = [cos(t), sin(t)];    xy = [r r] .* cs;   % dot positions in Cartesian coordinates (pixels from center)    mdir = 2 * floor(rand(ndots,1)+0.5) - 1;    % motion direction (in or out) for each dot    dr = pfs * mdir;                            % change in radius per frame (pixels)    dxdy = [dr dr] .* cs;                       % change in x and y per frame (pixels)    % Create a vector with different colors for each single dot, if    % requested:    if (differentcolors==1)        colvect = uint8(round(rand(3,ndots)*255));    else        colvect=white;    end;        % Create a vector with different point sizes for each single dot, if    % requested:    if (differentsizes>0)        s=(1+rand(1, ndots)*(differentsizes-1))*s;            end;        buttons=0;            % --------------    % animation loop    % --------------    i=0;           for j=1:nRepeat;    ss=breakSecs(j)-stimSecs/4*[3 2 1];    ck.motionStart(j)=getsecs-startSecs;    while (getsecs<breakSecs(j))%-stimSecs)                i=i+1;                        if (i>1)            Screen('FillOval', w, uint8(white), fix_cord);	% draw fixation dot (flip erases it)            Screen('DrawDots', w, xymatrix, s, colvect, center,1);  % change 1 to 0 to draw square dots            Screen('DrawingFinished', w); % Tell PTB that no further drawing commands will follow before Screen('Flip')        end;                [mx, my, buttons]=GetMouse(screenNumber);        %if KbCheck | find(buttons) % break out of loop        %    break;        %end;        xy = xy + dxdy;						% move dots        r = r + dr;							% update polar coordinates too        % check to see which dots have gone beyond the borders of the annuli        r_out = find(r > rmax | r < rmin | rand(ndots,1) < f_kill);	% dots to reposition        nout = length(r_out);        if nout            % choose new coordinates            r(r_out) = rmax * sqrt(rand(nout,1));            r(r<rmin) = rmin;            t(r_out) = 2*pi*(rand(nout,1));            % now convert the polar coordinates to Cartesian            cs(r_out,:) = [cos(t(r_out)), sin(t(r_out))];            xy(r_out,:) = [r(r_out) r(r_out)] .* cs(r_out,:);            % compute the new cartesian velocities            dxdy(r_out,:) = [dr(r_out) dr(r_out)] .* cs(r_out,:);        end;        xymatrix = transpose(xy);                if (doublebuffer==1)            vbl=Screen('Flip', w, vbl + (waitframes-0.5)*ifi);                     end;         %pause(0.001);         %pause;         if i==2 %start of exerpiment             WaitTill(startSecs+lagg-0.01);                    end            end    ck.motionEnd(j)=getsecs-startSecs;    waitsecs(stimSecs);        %[fff, secs]=WaitTill(j*blockSecs+lagg+startSecs);end;ck.EndOfExperiment=getsecs-startSecs;Priority(0);Screen('CloseAll'); ShowCursor;    